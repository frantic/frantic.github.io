<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=640" />

    <title>React API evolution / frantic.im</title>
    <meta name="author" content="Alex Kotliarskyi">
    <meta name="description" content="From React.createClass to hooks: why React is at odds with JavaScript">

    <link rel="canonical" href="https://frantic.im/react-api-evolution">
    <link rel="alternate" type="application/rss+xml" title="frantic.im" href="https://frantic.im/feed.xml">

    <meta property="og:title" content="React API evolution">
    <meta property="og:image" content="https://frantic.im/assets/react-api-evolution/og-image.png">
    <meta name="og:description" content="From React.createClass to hooks: why React is at odds with JavaScript">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@alex_frantic">
    <meta name="twitter:creator" content="@alex_frantic">
    <meta name="twitter:title" content="React API evolution">
    <meta name="twitter:description" content="From React.createClass to hooks: why React is at odds with JavaScript">
    <meta name="twitter:image" content="https://frantic.im/assets/react-api-evolution/og-image.png">

    <link id="favicon" rel="icon" type="image/png" href="/favicon.png">
    <script>
      if ('ethereum' in window) {
        document.getElementById('favicon').href = '/assets/favicon-hex.png';
      }
    </script>

    <style type="text/css" media="screen">
      * {
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  box-sizing: border-box;
}

@font-face { font-family: 'body';                     src: url('/fonts/IBMPlexSans-Text.woff') format('woff'); }
@font-face { font-family: 'body'; font-style: italic; src: url('/fonts/IBMPlexSans-TextItalic.woff') format('woff'); }
@font-face { font-family: 'body'; font-weight: 800;   src: url('/fonts/IBMPlexSans-Bold.woff') format('woff'); }

@font-face { font-family: 'mono';                     src: url('/fonts/IBMPlexMono-Text-Latin1.woff') format('woff'); }

body { font: 18px/28px body, sans-serif; }
pre, code { font-family: mono, monospace; }

body {
  background-color: #FFF;
  color: #000;
  -webkit-font-feature-settings: "kern" 1,"liga" 1,"calt" 1;
  -moz-font-feature-settings: "kern" 1,"liga" 1,"calt" 1;
  font-feature-settings: "kern" 1,"liga" 1,"calt" 1;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: optimizeLegibility;
  margin: 50px auto;
}
.page { width: 600px; margin: 0 auto; padding: 0 0 0 2px; }
.page_wide { width: 810px; }

.menu { width: 544px; margin: 0 auto 0; padding: 0 0 50px 0; vertical-align: top; }
.menu > li { list-style: none; display: inline-block; margin: 0 1.5em 0 0; vertical-align: top; }
.menu__item, a.menu__item { color: #00000050; border-color: transparent; display: inline-block; }
.menu__item_selected,
a.menu__item_selected,
a.menu__item:hover { color: #000; border-bottom: 2px solid #000; }
.menu__item_inside, a.menu__item_inside { border-bottom: 2px solid #00000030; }

article { width: 544px; margin: 15px auto; }

a { color: inherit; text-decoration: none; border-bottom: 2px solid #00000030; }
a:hover { border-color: currentColor; }
p, blockquote { margin: 15px 0; }
h1 + p + blockquote { margin-bottom: 30px; margin-right: 1em; }
blockquote { padding-left: 1em; color: #00000090; }
blockquote::before {content: "> "; float: left; margin: 0 0 0 -1em; }

.quote-author { text-align: right; font-size: 15px; }
strong { font-weight: 600; }
h1, h2 { margin: 2.5em 0 0.5em; }
h1 { font-size: 1.7em; }
h2 { font-size: 1.4em; }
.title { font-size: 2.5em; line-height: 50px; margin: 1.5em 0 0.75em 0; }

p > img, .fig, figure { margin: 2em 0; }
img { max-width: 100%; }

.fig, figure { text-align: center; font-size: 12px; line-height: 20px; font-style: italic; width: 600px; margin-left: -28px; margin-right: -28px; }
.fig img, figure > img, figure > video, figure > a > img { margin: 0 auto 1em; display: block; border-radius: 3px; }
figure > video { max-width: 100%; }
.label { text-align: center; font-size: 12px; font-style: italic; margin: -1em 0 1em 0; }

code { font-style: normal; background: #00000010; padding: 2px 6px; border-radius: 4px; font-size: 17px; white-space: nowrap; }
pre { font-size: 16px;
      background: #00000010;
      padding: 16px 30px 14px;
      margin: 1em -30px;
      border-radius: 8px;
      white-space: pre;
      word-wrap: break-word;
      font-style: normal;
      overflow-x: auto; }
pre > code { background: none; padding: 0; font-size: inherit; white-space: unset; }

ul { padding: 0 0 0 1em; list-style-type: square; }
ul > li, ol > li { margin: 0.5em 0; }

sup, sub, .note-ref, .note-number, .footnote { vertical-align: baseline; position: relative; font-size: .7em; line-height: 1; }
sup, .note-ref, .note-number, .footnote { bottom: 1.4ex; }
sub { top: .5ex; }

.about { margin: 60px 0;}
.about_photo { float: left; width: 100px; height: 160px; margin-left: -150px; margin-top: -10px; background: url("/photo.png"); background-size: 200px; }
.about_photo:hover { background-position: 100%; }
.about_inner { font-size: 16px; line-height: 24px; border: 2px solid #00000030; border-radius: 4px; padding: 10px 20px; margin: -12px -22px; }
.about_inner > p { margin: 0; }
.about_inner > p:not(:last-child) { margin-bottom: 8px; }
.btn-subscribe { line-height: 20px; text-decoration: none; background: #00000015; border: none; font-size: 12px; padding: 0px 7px; display: inline-block; border-radius: 4px; position: relative; top: -1px; }
.btn-subscribe:hover { background: #00000030; }
.btn-subscribe > svg { width: 21px; height: 21px; vertical-align: bottom; margin: 0 -2px 0 -5px; }

.footnote { margin: 0 5px;  }
.footnotes-br { width: 100px; height: 2px; background: #000000; margin-top: 5em; }
.footnotes, .footnotes_alt { padding-left: 1em;  }
.footnotes_alt > li > .dagger { margin-left: -13px; }
.footnotes_alt { list-style: none; } 

.notes { font-size: 0.8em; }
.note-number { margin-left: -1em; }

.date { color: #00000090; font-size: 14px; margin-left: 4px; }

footer { color: #00000090; }
footer { font-size: 16px; margin-bottom: 5em; }
footer > .separator { margin: 0 4px; }
footer > a { margin-right: 5px; }
footer > a:hover { color: #000; }

/* syntax */
.highlight .kd, .highlight .k {font-weight: bold; }
.highlight .mi { color: blue; }
.highlight .cm { color: grey; }

.hljs-built_in, .hljs-keyword {font-weight: bold; }
.hljs-string, hljs-number { color: blue; }
.hljs-comment { color: grey; }
      
    </style>
  </head>

  <body>
    <ul class="menu">
  
  <li>
    <a class="menu__item " style="" href="/blog/">
      Blog
    </a>
  </li>
  
  <li>
    <a class="menu__item " style="" href="/talks/">
      Talks
    </a>
  </li>
  
  <li>
    <a class="menu__item " style="" href="/projects/">
      Projects
    </a>
  </li>
  
  <li>
    <a class="menu__item " style="" href="/about/">
      About
    </a>
  </li>
  
</ul>


<article>
  <header>
    
    <h1 class="title">React API evolution</h1>
  </header>
  <p>React is ~8 years old. I remember the day when I saw the first demo — I was amazed at how genius yet how simple it was! I still carry that excitement to this day.</p>
<p>During this time React changed a bunch, but its core ideas have stayed the same. It’s still all about thinking about your UI code as a function of state, bringing state front and center, immutable data, one-directional data flows, composition over inheritance.</p>
<p>In this post I’ll share how the developer APIs have evolved, specifically we’ll talk about defining components and sharing common code between components.</p>
<iframe style="max-width: 100%" width="560" height="315" src="https://www.youtube-nocookie.com/embed/QEGbuc-sKtE?rel=0" frameborder="0" allowfullscreen></iframe>
<h2>2013, <a href="https://web.archive.org/web/20130607112820/http://facebook.github.io/react/">React v0.3.0</a>: <code>React.createClass</code></h2>
<pre><code class="language-js"><span class="hljs-comment">/** <span class="hljs-doctag">@jsx</span> React.DOM */</span>
<span class="hljs-keyword">var</span> <span class="hljs-title class_">Timer</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createClass</span>({
  <span class="hljs-attr">propTypes</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>,
  },
  <span class="hljs-attr">getInitialState</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">seconds</span>: <span class="hljs-number">0</span> };
  },
  <span class="hljs-attr">tick</span>: <span class="hljs-title class_">React</span>.<span class="hljs-title function_">autoBind</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">seconds</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">seconds</span> + <span class="hljs-number">1</span> });
  }),
  <span class="hljs-attr">componentDidMount</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tick</span>, <span class="hljs-number">1000</span>);
  },
  <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        Hello, {this.props.name}! It&#x27;s been {this.state.seconds} seconds
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  },
});

<span class="hljs-title class_">React</span>.<span class="hljs-title function_">renderComponent</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Timer</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Alex&quot;</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;main&quot;</span>));
</code></pre>
<p>Initeresting things to note here:</p>
<ol>
<li><code>/** @jsx React.DOM */</code> was required for the JSXTransformer to convert XML-in-JS syntax (like <code>&lt;div&gt;Hello&lt;/div&gt;</code>) to function calls (like <code>React.DOM.div({}, 'Hello')</code>)</li>
<li><code>React.createClass</code> was used to create a component. I think in hindsight naming it <code>Class</code> and not <code>Component</code> was a big marketing mistake: with ES6 classes many people were pushing for React to adopt the “standard” way, although it had a lot of problems (more on that later).</li>
<li>In development, React performed <code>props</code> validation at runtime (Flow and TypeScript didn’t exist back then), and the <code>PropTypes</code> API allowed for pretty complex definitions with nested objects and arrays.</li>
<li>Initially, without <code>React.autoBind</code> the methods on the components had dynamically scoped <code>this</code>, which was pretty confusing: calling <code>this.tick</code> would result in something like “Can’t call <code>setState</code> of unndefined”. <code>autoBind</code> was doing something like <code>fn.bind(this)</code> to fix it on per-function basis, and eventually this behavior was moved directly into <code>React.createClass</code>.</li>
<li>React focused on a pure, functional, declarative approach to bulding UIs, but also had escape hatches that allowed programmers take imperative actions or talk to DOM when needed via lifecycle methods and refs.</li>
</ol>
<p>If you look carefully at the example above, you’ll notice that there’s a memory leak! We <code>setInterval</code> without <code>clearInterval</code>-ing it. To fix the problem we’d have to call <code>clearInterval</code> from <code>componentWillUnmount</code>, however that wasn’t obvious from the APIs and programmers had to watch out for patterns like this.</p>
<p>That was a common pitfall: managing resources and making sure parts that were not managed by React were in sync with the UI.</p>
<p>It was clear there’s a need for a way for the components to share behavior traits. Early versions of React shipped with a solution to this problem: mixins.</p>
<h3>Mixins</h3>
<pre><code class="language-js"><span class="hljs-comment">/** <span class="hljs-doctag">@jsx</span> React.DOM */</span>

<span class="hljs-keyword">var</span> <span class="hljs-title class_">SetIntervalMixin</span> = {
  <span class="hljs-attr">componentWillMount</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">intervals</span> = [];
  },
  <span class="hljs-attr">setInterval</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, interval</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">intervals</span>.<span class="hljs-title function_">push</span>(<span class="hljs-built_in">setInterval</span>(callback, interval));
  },
  <span class="hljs-attr">componentWillUnmount</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">intervals</span>.<span class="hljs-title function_">map</span>(<span class="hljs-built_in">clearInterval</span>);
  },
};

<span class="hljs-keyword">var</span> <span class="hljs-title class_">TickTock</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createClass</span>({
  <span class="hljs-attr">mixins</span>: [<span class="hljs-title class_">SetIntervalMixin</span>],

  <span class="hljs-attr">getInitialState</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">seconds</span>: <span class="hljs-number">0</span> };
  },
  <span class="hljs-attr">componentDidMount</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-built_in">setInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tick</span>, <span class="hljs-number">1000</span>);
  },
  <span class="hljs-attr">tick</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">seconds</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">seconds</span> + <span class="hljs-number">1</span> });
  },
  <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>It&#x27;s been {this.state.seconds} seconds<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
  },
});
</code></pre>
<p>The code above fixes the memory leak and makes it easier to avoid this problem in the future: just include <code>SetIntervalMixin</code> and you are good to go!</p>
<p>Mixins fixed some problems, but intruduced others: implicit dependencies, name clashes and snowballing complexities. <a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html">Read more on the official blog post (2016)</a>.</p>
<h2>2015, <a href="https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html">React v0.13</a>: <code>class extends React.Component</code></h2>
<p>The big feature of this release was ES6 class support:</p>
<blockquote>
<p>JavaScript originally didn’t have a built-in class system. Every popular framework built their own, and so did we. This means that you have a learn slightly different semantics for each framework.</p>
</blockquote>
<blockquote>
<p>We figured that we’re not in the business of designing a class system. We just want to use whatever is the idiomatic JavaScript way of creating classes.</p>
</blockquote>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = {<span class="hljs-attr">seconds</span>: <span class="hljs-number">0</span>};
  }
  <span class="hljs-title function_">tick</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({<span class="hljs-attr">seconds</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">seconds</span> + <span class="hljs-number">1</span>});
  }
  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) {
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-number">1000</span>);
  }
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        Hello, {this.props.name}! It&#x27;s been {this.state.seconds} seconds
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
});

<span class="hljs-title class_">Counter</span>.<span class="hljs-property">propTypes</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>,
};
</code></pre>
<p>However, in my opinion ES6 classes didn’t fix the problem, but made it worse.</p>
<p>First, the benefits weren’t super valuable. React shipped <code>Component</code> and <code>PureComponent</code> to inherit from, inheriting other components was discouraged (in favor of <a href="https://reactjs.org/docs/composition-vs-inheritance.html">composition</a>).</p>
<p>Second, the semantics resulted in a bunch of ergonomics problems.</p>
<p>In the example above, if you forgot to do <code>this.tick.bind(this)</code>, you’ll get the same “Can’t call <code>setState</code> of unndefined” as in pre-<code>autoBind</code> days. There were several popular ways to address this, none of them seemed ideal though:</p>
<ul>
<li>Do it inline: easy to forget, <code>bind</code> returns a new function instance for every call (which hurts if you rely on <code>shouldComponentUpdate</code>):</li>
</ul>
<pre><code class="language-js">&lt;button onClick={<span class="hljs-variable language_">this</span>.<span class="hljs-property">increment</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)} /&gt;
</code></pre>
<ul>
<li>Do it in the constructor: verbose, easy to miss:</li>
</ul>
<pre><code class="language-js"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);
}
</code></pre>
<ul>
<li>Arrow functions + E7 property initializers: its syntax is inconsistent with method definitions in subtle ways (also note <code>;</code> at the end of <code>tick</code>):</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  tick = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// ...</span>
  };

  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) {
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tick</span>, <span class="hljs-number">1000</span>);
  }
}
</code></pre>
<h3>Higher-order components</h3>
<p>As mixing were goin away, the developers needed to fill the gap: find a way to reuse common functionality across components.</p>
<p>HoC became a popular replacement for mixins. You can think of the pattern as writing a function that takes a component as its argument, and returns a new component that wraps it with some useful enhancement.</p>
<p>Here’s an example of HoC that does the same thing as the <code>SetIntervalMixin</code> from the earlier example:</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">withTimer</span>(<span class="hljs-params">Component</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">Component</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
      <span class="hljs-variable language_">super</span>(props);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">intervals</span> = [];
    }
    <span class="hljs-built_in">setInterval</span> = <span class="hljs-function">(<span class="hljs-params">callback, interval</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">intervals</span>.<span class="hljs-title function_">push</span>(<span class="hljs-built_in">setInterval</span>(callback, interval));
    };
    <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">intervals</span>.<span class="hljs-title function_">map</span>(<span class="hljs-built_in">clearInterval</span>);
    }
    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
      <span class="hljs-comment">// Render the original component with some additional props</span>
      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> {<span class="hljs-attr">...this.props</span>} <span class="hljs-attr">setInterval</span>=<span class="hljs-string">{this.setInterval}</span> /&gt;</span></span>
    }
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = {<span class="hljs-attr">seconds</span>: <span class="hljs-number">0</span>};
  }
  <span class="hljs-title function_">tick</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({<span class="hljs-attr">seconds</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">seconds</span> + <span class="hljs-number">1</span>});
  }
  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-built_in">setInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>));
  }
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        Hello, {this.props.name}! It&#x27;s been {this.state.seconds} seconds
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
});
</code></pre>
<p>HoC promise is to use functional composition to solve the trait problem. But they do come with their own drawbacks too, especially around the ergonomics:</p>
<ol>
<li>Creating and using them is verbose, it’s not uncommon to end up with wrappers on top of wrappers, e.g. <code>withTranslations(withTimer(connect()(Timer)))</code>.</li>
<li>This indirection breaks <code>refs</code> and makes writing pure components harder, unless implemented carefully.</li>
<li>Devtools show very deep wrapped component hierarchies that hurt readability:</li>
</ol>
<p><img src="/assets/react-api-evolution/deep-hocs.png" alt="" /></p>
<h3>Render props</h3>
<p>React community kept looking for better ways to reuse logic in components and for some time a pattern called “render props” gained a bunch of popularity. I’m not going to dive into these dark ages, but the idea was similar to HoC.</p>
<h2>2019, <a href="https://reactjs.org/blog/2019/02/06/react-v16.8.0.html">React v16.8</a>: Hooks</h2>
<p>Around the time the release with ES6 was published, the React team made it possible to define components as simple functions, aka “stateless functional components”:</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Timer</span>(<span class="hljs-params">props</span>) {
  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello, {props.name}!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-title class_">React</span>DOM.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Timer</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Alex&quot;</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;main&quot;</span>));
</code></pre>
<p>This was very popular: simple, concise, idiomatic. However, how do you get access to state or lifecycle methods?</p>
<p>After a bunch of prototyping and explorations, the React team presented the way – hooks.</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Timer</span>(<span class="hljs-params">props</span>) {
  <span class="hljs-keyword">const</span> [seconds, setSeconds] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setSeconds</span>(<span class="hljs-function">(<span class="hljs-params">s</span>) =&gt;</span> s + <span class="hljs-number">1</span>), <span class="hljs-number">1000</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-built_in">clearInterval</span>(interval);
    };
  }, []);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      Hello, {props.name}! It&#x27;s been {seconds} seconds
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>Programmers familiar with algebraic effects saw the striking similarities.</p>
<p>Notably, the mental model of hooks shifted from “lifecycle methods” to “sync things outside React’s control with UI”.</p>
<p>For example, <code>useEffect</code> is built in a way that makes it easy to colocate resource acquisition and release, making memory leaks much easier to avoid. The second argument to <code>useEffect</code> is a list of dependencies, if any of them change between calls to the same <code>useEffect</code>, React will clean up the previous one and will recreate a new one. Getting this right with <code>componentDidMount</code> / <code>componentWillReceiveProps</code> / <code>componentWillUnmount</code> was hard.</p>
<p>Hooks have solved the problem of sharing common functionality across components in a very elegant, composable ways:</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useInterval</span>(<span class="hljs-params">callback, ms</span>) {
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> interval = <span class="hljs-built_in">setInterval</span>(callback, ms);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-built_in">clearInterval</span>(interval);
    };
  }, [callback, ms]);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Timer</span>(<span class="hljs-params">props</span>) {
  <span class="hljs-keyword">const</span> [seconds, setSeconds] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-title function_">useInterval</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setSeconds</span>(<span class="hljs-function">(<span class="hljs-params">s</span>) =&gt;</span> s + <span class="hljs-number">1</span>), <span class="hljs-number">1000</span>);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      Hello, {props.name}! It&#x27;s been {seconds} seconds
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>But hooks were not without problems either: in the example above there’s a subtle problem with the callback we pass to <code>useInterval</code>: since it’s a new referance every time (in JS, <code>() =&gt; {}</code> !== <code>() =&gt; {}</code>) we end up re-creating interval every render. The solution looks like this:</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Timer</span>(<span class="hljs-params">props</span>) {
  <span class="hljs-keyword">const</span> [seconds, setSeconds] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> increment = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setSeconds</span>(<span class="hljs-function">(<span class="hljs-params">s</span>) =&gt;</span> s + <span class="hljs-number">1</span>), []);
  <span class="hljs-title function_">useInterval</span>(increment, <span class="hljs-number">1000</span>);

  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>Compared to <code>React.Component</code> and mixins, React Hooks traded <code>this</code> and related class gotchas for JS scope gotchas. I think it was a good trade to make.</p>
<h1>Conclusions</h1>
<ol>
<li>React did an awesome job keeping the API surface very small. Watching the documentation across all these years felt like the team is actively <em>removing</em> things that are non-essential.</li>
<li>React evolved in a steady, backwards-compatible way. You can still use <code>React.createClass</code> APIs via a package, if you want to. Facebook code written in 2013 still works fine (after applying minor codemods).</li>
<li>React is at odds with JavaScript: from JSX syntax, ES6 class method bindings gotchas to reinvention of algebraic effects.</li>
</ol>

  <footer>
    <time datetime="2021-03-11T12:00:00+00:00">Mar 11, 2021</time>
  </footer>
  






  <h4>Related posts:</h4>
  

  

    

    
      
        
      
    

    

  

    

    

    

  

    

    

    

  

    

    
      
        
      
    

    

  

    

    

    

  

    

    

    

  

    

    

    

  

    

    

    

  

    

    

    

  

    

    
      
        
      
    

    

  

    

    

    

  

    

    
      
    
      
    

    

  

    

    
      
        
      
    

    

  

    

    

    

  

    

    

    

  

    

    

    

  

    

    

    

  

    

    

    

  

    

    

    

  

    

    

    

  

    

    
      
        
          
        
      
    
      
        
      
    
      
        
      
    

    
      <p>
        <a href="/how-not-to-flux-set-actions">How not to use Flux: SET actions</a>
      </p>
      
      
    

  

    

    
      
        
      
    
      
        
      
    

    

  

    

    
      
        
      
    
      
        
      
    

    

  

    

    
      
        
      
    

    

  

    

    
      
        
      
    
      
        
          
        
      
    

    
      <p>
        <a href="/react-conf-2018">React Conf 2018 Recap</a>
      </p>
      
      
    

  

    

    
      
        
          
        
      
    
      
        
      
    
      
        
      
    

    
      <p>
        <a href="/how-not-to-flux-loops">How not to use Flux: mini cycles</a>
      </p>
      
      
    

  

    

    

    

  

    

    
      
        
      
    
      
        
      
    
      
        
      
    

    

  

    

    
      
        
      
    
      
        
      
    
      
        
      
    

    

  

    

    
      
        
      
    
      
        
      
    
      
        
      
    

    

  

    

    
      
        
      
    

    

  

    

    
      
        
      
    
      
        
          
        
      
    
      
        
      
    

    
      <p>
        <a href="/react-and-javascript-in-5-min">React-flavored JavaScript in 5 minutes</a>
      </p>
      
      
        



  <div class="about">
  <div class="about_inner">
    <p>Hello! This text lives here to convince you to subscribe. If you are reading this, consider clicking that subscribe button for more details.</p>
    <p>I write about programming, software design and side projects <a style="margin-left: 5px" class="btn-subscribe" href="/subscribe/" target="_blank"><svg viewBox="0 0 800 800"><path d="M493 652H392c0-134-111-244-244-244V307c189 0 345 156 345 345zm71 0c0-228-188-416-416-416V132c285 0 520 235 520 520z"/><circle cx="219" cy="581" r="71"/></svg> Subscribe</a></p>
  </div>
</div>

</article>

    <script defer src="https://u.frantic.im/script.js" data-website-id="cd2ea49a-5998-477e-8f35-a6ab8d2df514"></script>
  </body>
</html>
